### 超文本传送协议HTTP
#### HTTP的操作过程
+ `HTTP协议`定义了浏览器(万维网客户端进程)怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器，`HTTP`是`面向事务的`应用层协议，它是万维网上能够可靠的交换文件的重要基础；在浏览器和服务器之间的请求和响应的交互，必须按照`规定的格式和遵循一定的规则`，这些`格式和规则`就是`超文本传送协议HTTP`；`HTTP`规定在`HTTP客户`与`HTTP服务器`之间的每次交互，都由一个`ASCII码串`构成的`请求`和一个类似的`通用因特网邮件扩充即类MIME`的`响应`组成，`HTTP报文`通常都使用`TCP`连接传送；

+ `HTTP`使用了面向连接的`TCP`作为运输层协议，保证了数据的可靠传输，`HTTP`不必考虑数据在传输过程中被丢弃后又怎样被重传，但是，`HTTP`协议`本身是无连接的`，就是说，虽然`HTTP`使用了`TCP`连接，但通信的双方在交换`HTTP报文`之前不需要先建立`HTTP连接`；`HTTP`协议的`无状态的`，也就是说，同一个客户第二次访问同一个服务器上的页面时，服务器的响应与第一次被访问时的相同；

+ 万维网客户把`HTTP请求报文`作为`三次握手`的`第三个报文`的数据发送给万维网服务器，服务器收到HTTP请求报文后，就把所请求的文档作为响应报文返回给客户；`HTTP`使用了`持续连接`，持续连接就是万维网服务器在发送响应后仍然在一段时间内保持这条连接，使同一个客户和该浏览器可以继续在这条连接上传送后续的`HTTP请求报文和响应报文`，这并不局限于传送同一个页面上链接的文档，而是只要这些文档都在同一个服务器上就行；

|持续连接两种工作方式|说明|
|------|------|
|非流水线方式|是客户在收到前一个响应后才能发出下一个请求，因为服务器在发送完一个对象后，其TCP连接就处于空闲状态，浪费了服务器资源|
|流水线方式|是客户在收到HTTP的响应报文之前就能接着发送新的请求报文，于是一个接一个的请求报文到达服务器后，服务器就可持续发回响应报文|

#### 代理服务器
+ `代理服务器`是一种网络实体，它又称为`万维网高速缓存`，代理服务器把最近的一些请求和响应暂存在`本地磁盘`中，当新请求到达时，若代理服务器发现这个请求与暂存的请求相同，就返回暂存的响应；

#### HTTP的报文结构
+ `HTTP`是`面向文本的`，因此在报文中的每一个字段都是一些`ASCII码串`，因而各个字段的长度都是`不确定的`；


|字段|说明|
|------|------|
|开始行|用于区分是请求报文还是响应报文，在请求报文中的开始行叫做请求行，而在响应报文中的开始行叫做状态行，最后的CR和LF分别代表回车和换行|
|首部行|用来说明浏览器、服务器和报文主体的一些信息，每一行在结束的地方都要有回车和换行，整个首部行结束时，还有一空行将首部和后面的实体主体分开|
|实体主体|在请求报文中一般都不用这个字段，而在响应报文中也可能没有这个字段|

#### 请求报文

|请求行字段|说明|
|------|------|
|方法|就是对所请求的对象进行的操作，这些方法实际上也就是一些命令；OPTION：请求一些选项的信息；GET：请求读取由URL所标志的信息；HEAD：请求读取由URL所标志的信息的首部；POST：给服务器添加信息；PUT：在指明的URL下存储一个文档；DELETE：删除指明的URL所标志的资源；TRACE：用来进行环回测试的请求报文；CONNECT：用于代理服务器|
|URL|请求资源的URL|
|版本|HTTP的版本|

```
//请求报文的例子 GET http://www,tsinghua.edu.cn/chn/yxsz/index.htm HTTP/1.1

GET /chn/yxsz/index.htm HTTP/1.1       //请求行使用了相对URL

Host：www.tsinghua.edu.cn       //此行是首部行的开始，这行给出主机的域名

Connection：close       //告诉服务器发送完请求的文档后就可释放连接

User-Agent：Mozilla/5.0       //表明用户代理是使用Netscape浏览器

Accept-Language：cn       //表示用户希望优先得到中文版本的文档
```
#### 响应报文

|状态行字段|说明|
|------|------|
|版本|HTTP的版本|
|状态码|状态码；状态码都是三位数字的如：1xx：表示通知信息的，如请求受到了或正在进行处理；2xx：表示成功，如接受或知道了；3xx：表示重定向，如要完成请求还必须采取进一步的行动；4xx：表示客户的差错，如请求中有错误的语法或不能完成；5xx：表示服务器的差错，如服务器失效无法完成请求|
|短语|解释状态码的简单短语|

#### 在服务器上存放用户的信息
+ `HTTP中使用了Cookie`，对`Cookie`进行了定义，规定万维网站点可以使用`Cookie`来`跟踪用户`，在这里`Cookie`表示在HTTP服务器和客户之间传递的状态信息；`Cookie`是这样工作的，当用户A浏览某个使用`Cookie`的网站时，该网站的服务器就为`A`产生一个`唯一`的`识别码`，并以此作为索引在服务器的后端数据库中产生一个项目，接着在给`A`的`HTTP响应报文`中添加一个叫做`Set-Cookie`的首部行，这里的`首部字段名`就是`Set-Cookie`，而后面的`值`就是赋予该用户的`识别码`如：`Set-Cookie：12345678`，当`A`收到这个响应时，其浏览器就在它管理的特定`Cookie`文件中添加一行，其中包括这个服务器的`主机名`和`Set-Cookie`后面给出的`识别码`，当`A`继续浏览这个网站时，每发送一个`HTTP`请求报文，其浏览器就会从其`Cookie文件`中取出这个网站的`识别码`，并放到`HTTP请求报文`的`Cookie`首部行中如：`Cookie：12345678`，于是，这个网站就能够跟踪用户`12345678`在该网站的活动；
### http协议特点

|http协议特点|
|------|
|`简单快速`传送请求方法(get、post)和路径就可以获取需要的数据|
|`无连接`指的是`限制每次连接只处理一个请求`，`服务器处理完客户的请求之后，会受到客户端的应答，然后断开这个连接`|
|`无状态`指的是`这个协议对以前处理的事物没有记忆能力`|

### Uri与Url的区别

|URI与URL区别|说明|
|------|------|
|`URI`|是Uniform resource identifier `统一资源标识符，用来唯一的标识一个资源`；`URI`的三个组成部分：一、`访问资源的命名机制`；二、`存放资源的主机名`；三、`资源自身的名称，由路径表示，着重强调与资源`|
|`URL`|是Uniform resource licator`统一资源定位器，它是一种具体的URI，及URL可以用来标识一个资源，而且还指明了如何定位这个资源`；`URL`的三个组成部分：一、`协议`如`HTTP、HTTPS`；二、`存有该资源的主机IP地址`；三、`主机资源的具体地址`强调的是路径|

### http协议request/response原理
+ `当在浏览器中输入URL后，浏览器就会给web服务器发送request请求，而web服务器受到request请求之后就会进行相应的处理，生成相应的response，然后发送给浏览器，然后浏览器解析这个response中的html文档`；也可能`中间通过代理服务器，代理服务器可以提高访问速度，大多数代理服务器有缓存功能，当再次访问的时候，可以在缓存中获取`；
#### request请求头

|请求头|说明|
|------|------|
|`Host`|`请求的主机和端口号`是从URL中提取出来的|
|`User-Agent`|`客户端使用操作系统，浏览器的名称和版本`|
|`Accept`|`浏览器端可以接受的媒体类型`如：`txt、视频文件等`|
|`Referer`|`告诉服务器是从哪个页面链接过来的`|
|`Accept-Encoding`|`浏览器的编码方法`|
|`Accept-Language`|`浏览器可以接收的语言`|
|`if-None-Match`|`告诉response中可以添加一个ETag信息，当客户端再次请求这个资源的时候，就可以在request里面加上if-NoNE-Match的ETag的值，通过服务器验证ETag有没有改变，如果没有改变就返回一个304的状态码，来告诉客户端可以直接使用本地的缓存文件，就大大提高了性能`|
|`if-Modified-Since`|`把浏览器端缓存页面最后修改时间发送到服务器去，服务器将这个时间与指定资源的时间对比，如果一致返回304，如果不一致返回200表示获取成功，和新的文件内容，客户端受到新的文件之后会丢弃原有缓存文件，并将新的文件缓存起来`|

#### response响应头

|response响应头|说明|
|------|------|
|`Server`|`http服务器的信息`|
|`Date`|`表示生成该response的具体时间`|
|`Last-Modified`|`资源最后修改的时间`|
|`ETag`|`标志服务器端信息的标志位`|
|`Explres`|`表示浏览器在指定时间使用本地缓存过了这个时间将不能使用本地缓存，设置缓存的上限`|
|`Cache-Control`|`用来指定缓存机制`|
|`Proxy-Connection`|有`Keep-Alive，表示网页打开完成后，客户端和服务器端保持的TCP链接不会关闭，如果客户端再次访问这个服务器网页，就使用这条建立好的http链接，不会重新开辟链接`|

#### 实体报头
+ `实体报头`用来定义被传送资源的信息；既可用于请求也可以用于响应；

|实体报头|说明|
|------|------|
|Content-Type|发送给接收者的实体正文的媒体类型|
|Content-Length|实体正文的长度|
|Content-Language|描述资源所用的自然语言|
|Content-Encoding|内容编码|
|Last-Modified|实体报文用于指示资源的最后修改日期和时间|
|Expires|实体报头给出响应过期的日期和时间|

#### http请求方法有8种

|http请求方法种类|说明|
|------|------|
|GET|请求获取Request-URI所标识的资源|
|POST|在Request-URI所标识的资源后面附加新的数据|
|HEAD|请求获取由Request-URI所标识的资源的响应消息报头|
|PUT|请求服务器存储一个资源，并用Request-URI作为其标识|
|DELETE|请求服务器删除Request-URI所标识的资源|
|TRACE|请求服务器回送收到的请求信息，主要用于测试或诊断|
|CONNECT|http1.1协议中预留给能够将连接改为管道方式的代理服务器|
|OPTIONS|请求查询服务器的性能，或者查询与资源相关的选项和需求|

### get&post方法区别

|get&post方法区别|说明|
|------|------|
|`含义`|`get是获取服务器数据`；`post是更新服务器的数据`|
|`提交的数据`|`get提交的数据放在URL之后，用？来分割`；`post提交的数据基本上放在http包的属性封装类中`|
|提交数据的大小是否有限制|`get请求提交数据的大小是有限制的`；`post提交的数据大小是没有限制的`|
|`取得变量的值`|`get方式通过Request.QueryString方法来获取变量值的`；`post方法通过Request.form方法获取变量的值`|
|`安全问题`|`get方式提交数据会带来安全问题，因为传递数据时候，将数据链接到了URL上`；`post方式则不是这样的`|

### http协议中比较容易混淆的知识点
#### http1.0&http1.1的区别

|http1.0&http1.1的区别|说明|
|------|------|
|`http1.0产生的背景`|`超文本传输协议伴随着计算机网络和浏览器的诞生，http1.0也随之而来，处于计算机网络中的应用层，基于TCP协议`|
|`http1.0所做的优化`|`带宽`：`现阶段已经解决`；`延迟`：`一、浏览器阻塞：浏览器对于同一个域名，同时只能有4个连接；二、DNS查询：浏览器需要知道目标服务器的IP才能建立连接；三、建立连接：三次握手`|
|`http1.0&http1.1的区别`|`缓存处理`：`http1.0主要使用头部当中的if-Modified-Since作为缓存判断标准`，`http1.1引入了更多的缓存控制策略：如if-None-Match、ETag`；`带宽优化及网络连接的使用`：`http1.0存在一些浪费带宽的现象，不支持断点续传功能`；`http1.1中引入了Range范围的同步区域允许请求资源的某一个部分`；`Host头处理`：`http1.0中认为每台服务器绑定唯一的IP地址`；`长连接`：`http1.1支持长连接，就是说在一个tcp连接上可以传送多个http请求和响应，而不是发送一个http请求就断开连接，http1.1默认开启了Proxy-Connection ：Keep-Alive字段`|

#### http存在的问题

|http存在的问题|说明|
|------|------|
|`http1.0`|`HTTP1.0在传输数据时，每次都需要重新建立连接，无疑增加了大量的延迟时间`；解决方法：`使用http1.1`|
|`http1.x`|`在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份`；解决办法：`使用https`|
|`http1.1`|`在使用时，header里携带的内容过大，在一定程度上增加了传输的成本`；`虽然http1.1支持了keep-alive来弥补多次创建连接产生的延迟，但是keep-alive使用多了同样会给服务器带来大量的性能压力`|

### cookie&session的区别

|cookie&session的区别|说明|
|------|------|
|`cookie`|`cookie技术是客户端的解决方案，cookie就是由服务器发给客户端的特殊信息，而这些信息以文本文件的方式存放在客户端，然后客户端每次向服务器端发送请求的时候都会带上这些特殊的信息，该信息是存放在响应头中的，就是用户个人身份的标识`|
|`session`|`Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上，客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上`；工作原理：`创建Session；在创建Session的同时，服务器会为该Session生成唯一的Session ID；在Session被创建之后，就可以调用Session相关的方法往Session中增加内容，这些内容在服务器端，发送到客户端的只有Session ID；当客户端再次发送的时候，就将这个Session ID带上，服务器接受到请求之后就会依据Session ID找到相应的Session`|
|`区别`|`存放的位置不同`；`存取方式不同：cookies保存的是ASCII字符串；Session可以存放任何类型的数据`；`安全性不同`：`cookies相对不安全`；`有效期不同`：`一般设置cookie的有效时间很大；Session依赖ID，如果ID设置为-1，关闭浏览器就失效了`；`对服务器造成的压力不同`：`Session保存在服务器端，并发多的时候对服务器负担很严重`|

![image](https://github.com/ningbaoqi/ComputerNetWork/blob/master/gif/pic-204.jpg) 
